#define F_CPU 16000000UL

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <string.h>
#include <stdio.h>

// ==== LCD Configuration ====
#define LCD_DATA_PORT PORTC
#define LCD_DATA_DDR  DDRC
#define LCD_CTRL_PORT PORTB
#define LCD_CTRL_DDR  DDRB
#define LCD_RS        PB0
#define LCD_E         PB1
#define OVERFLOWS_PER_SECOND 977

void lcd_nibble(uint8_t nibble) {
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (nibble & 0x0F);
	LCD_CTRL_PORT |= (1 << LCD_E);
	_delay_us(1);
	LCD_CTRL_PORT &= ~(1 << LCD_E);
	_delay_us(1);
}

void lcd_command(uint8_t cmd) {
	LCD_CTRL_PORT &= ~(1 << LCD_RS);
	lcd_nibble(cmd >> 4);
	lcd_nibble(cmd & 0x0F);
	_delay_us(40);
}

void lcd_data(uint8_t data) {
	LCD_CTRL_PORT |= (1 << LCD_RS);
	lcd_nibble(data >> 4);
	lcd_nibble(data & 0x0F);
	_delay_us(40);
}

void lcd_init(void) {
	LCD_DATA_DDR |= 0x0F;
	LCD_CTRL_DDR |= (1 << LCD_RS) | (1 << LCD_E);
	_delay_ms(50);
	lcd_nibble(0x03); _delay_ms(5);
	lcd_nibble(0x03); _delay_us(150);
	lcd_nibble(0x03); _delay_us(150);
	lcd_nibble(0x02); // 4-bit mode
	lcd_command(0x28); // 2-line, 5x8
	lcd_command(0x0C); // display on, no cursor
	lcd_command(0x06); // entry mode
	lcd_command(0x01); // clear
	_delay_ms(2);
}

void lcd_clear(void) {
	lcd_command(0x01);
	_delay_ms(2);
}

void lcd_gotoxy(uint8_t x, uint8_t y) {
	lcd_command(0x80 + (y ? 0x40 : 0x00) + x);
}

void lcd_putc(char c) {
	lcd_data(c);
}

void lcd_puts(const char *s) {
	while (*s) lcd_putc(*s++);
}

// ==== Song List ====
#define TOTAL_SONGS 10

const char *titles[] = {
	"Go Robot",
	"Migra",
	"Expresso",
	"Sticky",
	"Judas",
	"Let It Be",
	"Africa",
	"Sweet Child O' Mine",
	"Thunderstruck",
	"Yesterday"
};

const char *artists[] = {
	"RHCP",
	"Santana",
	"Sabrina ",
	"TylerTC",
	"Led Zeppelin",
	"The Beatles",
	"Toto",
	"Guns N' Roses",
	"AC/DC",
	"The Beatles"
};

// ==== State ====
volatile int song_index = 0;
volatile int selected_song = -1;
volatile uint8_t update_display = 1;
volatile uint32_t last_scroll_time = 0;
volatile uint8_t rpg_moved = 0;
volatile uint8_t no_credit_flag = 0;
volatile uint32_t no_credit_time = 0;
volatile uint8_t credits = 3;

// ==== Timer0 for 1s Tick ====
void timer_init(void) {
	TCCR0A = 0;
	TCCR0B = (1 << CS01) | (1 << CS00);
	TIMSK0 = (1 << TOIE0);
	TCNT0 = 0;
}

ISR(TIMER0_OVF_vect) {
	static uint16_t count = 0;
	count++;
	if (count >= OVERFLOWS_PER_SECOND) {
		last_scroll_time++;
		count = 0;
	}
}

// ==== Rotary Encoder ====
void encoder_init(void) {
	DDRD &= ~((1 << PD2) | (1 << PD3));
	PORTD |= (1 << PD2) | (1 << PD3);
	EICRA |= (1 << ISC00);
	EIMSK |= (1 << INT0);
}

ISR(INT0_vect) {
	uint8_t A = (PIND & (1 << PD2)) >> PD2;
	uint8_t B = (PIND & (1 << PD3)) >> PD3;

	if (A != B)
	song_index = (song_index + 1) % TOTAL_SONGS;
	else
	song_index = (song_index == 0) ? TOTAL_SONGS - 1 : song_index - 1;

	last_scroll_time = 0;
	rpg_moved = 1;
	update_display = 1;
}

// ==== Push Button ====
#define BUTTON_PIN PD4

void button_init(void) {
	DDRD &= ~(1 << BUTTON_PIN);
	PORTD |= (1 << BUTTON_PIN);
}

uint8_t button_pressed(void) {
	static uint8_t last_state = 1;
	uint8_t current = PIND & (1 << BUTTON_PIN);
	if (!current && last_state) {
		_delay_ms(50);
		last_state = 0;
		return 1;
		} else if (current) {
		last_state = 1;
	}
	return 0;
}

// ==== LCD Custom Characters ====
uint8_t music_icon[8] = {
	0b00000,
	0b00100,
	0b00110,
	0b00101,
	0b00101,
	0b11100,
	0b11100,
	0b00000
};

void lcd_create_char(uint8_t location, uint8_t *charmap) {
	location &= 0x7;
	lcd_command(0x40 | (location << 3));
	for (int i = 0; i < 8; i++) {
		lcd_data(charmap[i]);
	}
}

// ==== Display Function ====
void display_song(int index) {
	lcd_clear();
	const char *title = titles[index];
	const char *artist = artists[index];
	size_t len = strlen(title);

	if (len <= 16) {
		lcd_gotoxy(0, 0);
		lcd_puts(title);
		lcd_gotoxy(0, 1);
		lcd_puts(artist);

		// music icon
		if (selected_song == index) {
			lcd_gotoxy(15, 1);
			lcd_putc(0);
		}

		// credit count
		char buf[6];
		snprintf(buf, sizeof(buf), "C:%u", credits);
		lcd_gotoxy(11, 1);
		lcd_puts(buf);
		return;
	}

	// Long title â€” scroll
	char buf[128];
	snprintf(buf, sizeof(buf), "%s   %s   ", title, title);
	size_t buf_len = strlen(buf);
	size_t scroll = 0;

	while (song_index == index && !update_display) {
		lcd_gotoxy(0, 0);
		for (int j = 0; j < 16; j++) {
			lcd_putc(buf[(scroll + j) % buf_len]);
		}

		lcd_gotoxy(0, 1);
		lcd_puts(artist);

		if (selected_song == index) {
			lcd_gotoxy(15, 1);
			lcd_putc(0);
		}

		char buf2[6];
		snprintf(buf2, sizeof(buf2), "C:%u", credits);
		lcd_gotoxy(11, 1);
		lcd_puts(buf2);

		if (button_pressed()) {
			if (credits > 0) {
				credits--;
				selected_song = index;
				} else {
				no_credit_flag = 1;
				no_credit_time = last_scroll_time;
			}
			update_display = 1;
			break;
		}

		_delay_ms(400);
		scroll = (scroll + 1) % buf_len;
	}
}

// ==== Main ====
int main(void) {
	lcd_init();
	lcd_create_char(0, music_icon);
	encoder_init();
	button_init();
	timer_init();
	sei();

	display_song(song_index);
	update_display = 0;

	uint32_t last_rpg_time = 0;

	while (1) {
		if (button_pressed()) {
			if (credits > 0) {
				if (selected_song == song_index) {
					// Song is already playing, show message
					no_credit_flag = 1;  // We will use no_credit_flag for showing this message
					no_credit_time = last_scroll_time;
					update_display = 1;
				} else {
					// Deduct credit and select song
					credits--;
					selected_song = song_index;
					last_scroll_time = 0;
					last_rpg_time = 0;
					update_display = 1;
				}
			} else {
				// No credits available, show "No credits!" message
				no_credit_flag = 1;
				no_credit_time = last_scroll_time;
				update_display = 1;
			}
		}


		if (rpg_moved) {
			last_rpg_time = last_scroll_time;
			rpg_moved = 0;
		}

		if (selected_song != -1 && song_index != selected_song &&
		(last_scroll_time - last_rpg_time >= 10)) {
			song_index = selected_song;
			last_scroll_time = 0;
			last_rpg_time = 0;
			update_display = 1;
		}

		if (no_credit_flag) {
			if ((last_scroll_time - no_credit_time) == 0) {
				lcd_clear();
				if (selected_song == song_index) {
					// Display "Song Already Playing!" on two lines
					lcd_gotoxy(0, 0);
					lcd_puts("Already Selected");
					lcd_gotoxy(0, 1);
					lcd_puts("  Choose Again");
					} else {
					// Display "No credits!" message on one line
					lcd_gotoxy(0, 0);
					lcd_puts("  No credits!");
					lcd_gotoxy(0, 1);
					lcd_puts("Scan RFID to add");
				}
			}
			if ((last_scroll_time - no_credit_time) >= 3) {
				no_credit_flag = 0;
				update_display = 1;
			}
			continue;
		}


		if (update_display) {
			update_display = 0;
			display_song(song_index);
		}
	}
}





//Push button
//PD4
//RPG Pin
//A	PD2 
//B	PD3 
//C GND
//| LCD Pin | Name | Connect To        | Notes                       |
//|---------|------|-------------------|-----------------------------|
//| 1       | VSS  | GND               | Ground                      |
//| 2       | VCC  | +5V               | Power                       |
//| 3       | V0   | resistor to ground| For contrast                |
//| 4       | RS   | PB0 (Pin 14)      | Register Select             |
//| 5       | RW   | GND               | Write only                  |
//| 6       | E    | PB1 (Pin 15)      | Enable                      |
//| 11      | D4   | PC0 (Pin 23)      | Data bit 4                  |
//| 12      | D5   | PC1 (Pin 24)      | Data bit 5                  |
//| 13      | D6   | PC2 (Pin 25)      | Data bit 6                  |
//| 14      | D7   | PC3 (Pin 26)      | Data bit 7                  |
//| 15      | LED+ | +5V			   | Backlight                 |
//| 16      | LED- | GND               | Backlight ground            |	
